/*
Brittany Bergeron
CS 3318, project 5
Diffie-Hellman exchange

Purpose:	Implements Diffie-Hellman Key Exchange Algorithm in C++. 
			Verify the inputs. 
			Compute the security keys generated by user A and user B respectively
			Verify they are the same. 
			
			In: prime numbers g,p (4000-10000) and secrets a,b (40-100)
			Out: shared secret key
*/

#include <fstream>
#include <iostream>
#include <cctype>
#include <cmath>
#include <string>

using namespace std;

int stringMod(string x, int y){ 

    //hold value to be modified and returned
    int modValue = 0; 
  
    //go through the string; break up huge modulo string by finding congruent pieces
    for(int i=0; i<x.length(); i++){
         modValue = ( (modValue*10) + ((int)x[i]) - '0') % y; 
	}
	//integer represents big modulo result
    return modValue; 
} 


int multiply(int x, int result[], int size) { 

	//remainder to carry over
	int remain = 0; 
	//go through result and multiply each base x by current index; add remainder
	for (int i = 0; i < size; i++) { 
		int hold = (result[i]*x) + remain; 

		//move hold digits to result array
		result[i] = hold % 10; 

		//left over is remainder
		remain = hold / 10; 
	} 

	//until remainder is 0, filter through to add values
	while (remain){ 
		result[size] = remain % 10; 
		remain = remain / 10; 
		size++; 
	}
	return size; 
} 

string bigPower(int x, int y) {
	
	//big array to store values
	int result[100000]; 
	//track actual size
	int size = 0;
	//keeps value of base for altering
	int hold = x; 

	//work through hold until 0 value( all checked)
	while(hold != 0){ 
		//find remainder and divide remaining by 10
		result[size++] = hold % 10; 
		hold = hold / 10; 
	} 

	// Multiply x; power of 0 and 1 ignored
	for (int i=2; i<=y; i++){
		//use multiply function to process
		size = multiply(x, result, size); 
	}
	
	string finalNumber;
	//starting at end of array, append values to final number
	for (int i=size-1; i>=0; i--) 
		finalNumber.append(to_string(result[i])); 

	return finalNumber;
} 

int main(){
	
	//since there are only a few primes to check, load in primes to array (save time)
	ifstream inFile("primes.txt");
	//error handling
	if(inFile.fail()){
		cerr<<"Error opening file\n";
		exit(1);
	}
	//hold each number in array size 679 (only matches prime within range
	int primes[679];
	int hold;
	for(int i =0; inFile>>hold; i++){
		//add current value to array
		primes[i] = hold;	
	}
	//close file
	inFile.close();	
	
	//hold prime numbers
	int g;
	int p;
	//ask user to input two prime numbers, g and p in range 4-10k
	cout << "Enter two prime numbers between 4000 and 10000 (the first one must be larger):\n";
	cin >> g;
	cin >> p;

	//check that numbers are in range and prime with primes array; use two booleans for each prime
	bool gIsMatch = false;
	bool pIsMatch = false;
	//g must be less than p
	bool gIsLess;
	
	//user is prompted until valid input
	while( (!gIsMatch) || (!pIsMatch) || (!gIsLess) ){
		//reset inside loop incase new input violates requirement
		gIsLess = false;
		if(p>g-1){
			cout << "the first number is not larger than the second, please pick two new numbers:\n";
			cin >>g;
			cin >>p;
		}
		else{
			//g is less than p, proceed
			gIsLess = true;
			//check each input against the valid primes listed (verifies in range)
			for(int i=0; i<679; i++){
				if(g == primes[i]){
					gIsMatch = true;			
				}
				if(p == primes[i]){
					pIsMatch = true;
				}
			}
		
			//if not prime, specify which is not prime and ask to change number
			if(!gIsMatch){
				cout << g << " is not a prime number between 4000 and 10000. Please enter  a replacement:\n";
				cin >> g;
			}
			if(!pIsMatch){
				cout << p << " is not a prime number between 4000 and 10000. Please enter  a replacement:\n";
				cin >> p;
			}
		}
		
	}

	//secret inputs
	int a;
	int b;
	//make sure valid in range
	bool aIsValid = false;
	bool bIsValid = false;
	//ask for number between 40 and 100 from each (private keys)
	cout << "Enter user A's private key between 40 and 100:\n";
	cin >> a;
	cout << "Enter user B's private key between 40 and 100:\n";
	cin >> b;
	//check for proper keys
	while( (!aIsValid) || (!bIsValid) ){
		//must be in range
		if( (a > 39) && (a < 101) ){
			aIsValid = true;
		}
		if( (b > 39) && (b < 101) ){
			bIsValid = true;
		}
		//if not valid, prompt users for new key
		if(!aIsValid){
			cout << a << " from user A is not a number between 40 and 100. Please enter  a replacement:\n";
			cin >> a;
		}
		if(!bIsValid){
			cout << b << " from user B is not a number between 40 and 100. Please enter  a replacement:\n";
			cin >> b;
		}
		
	}
	
	//generate security keys and verify they are the same (public keys)
		//Ta = (g^a)%p   Tb = (g^b)%p    ;    Tb^a%p == Ta^b%p == shared key
	//generate user A and B message to send
	int ta = stringMod( (bigPower(g,a)), p);	
	int tb = stringMod( (bigPower(g,b)), p);
	//using message, generate shared secret
	int shareda = stringMod( (bigPower(tb, a)), p);
	int sharedb = stringMod( (bigPower(ta, b)), p);
	//secret must be the same
	if(shareda != sharedb){
			cout << "error; keys do not match.\n";
	}
	//return public keys
	else{
		cout << "Shared key is: " << shareda << endl;
	}
	
	return 0;
}